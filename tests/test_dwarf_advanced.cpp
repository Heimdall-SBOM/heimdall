/*
Copyright 2025 The Heimdall Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
you may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <gtest/gtest.h>
#include <algorithm>
#include <chrono>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <random>
#include <thread>
#include "ComponentInfo.hpp"
#include "DWARFExtractor.hpp"
#include "MetadataExtractor.hpp"
#include "Utils.hpp"

using namespace heimdall;

/**
 * @file test_dwarf_advanced.cpp
 * @brief Advanced DWARF functionality tests for Heimdall
 *
 * IMPORTANT THREAD-SAFETY NOTE:
 * LLVM's DWARF libraries are NOT thread-safe and cannot be used concurrently.
 * Multiple DWARFExtractor instances should not be created simultaneously or
 * used from different threads. This limitation is documented in heimdall-limitations.md.
 *
 * These tests are designed to run serially and avoid concurrent DWARF operations.
 */

namespace heimdall {

class DWARFAdvancedTest : public ::testing::Test {
protected:
    void SetUp() override {
        test_dir = std::filesystem::temp_directory_path() / "heimdall_dwarf_advanced_test";
        std::filesystem::create_directories(test_dir);

        // Create complex C source file with multiple functions and debug info
        test_source = test_dir / "complex_test.c";
        std::ofstream(test_source) << R"(
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Global variables
int global_counter = 0;
const char* global_string = "test_string";

// Function declarations
int fibonacci(int n);
void bubble_sort(int arr[], int size);
char* reverse_string(const char* str);
double calculate_pi(int iterations);

// Main function
int main(int argc, char* argv[]) {
    printf("Complex test program\n");
    
    // Test fibonacci
    int fib_result = fibonacci(10);
    printf("Fibonacci(10) = %d\n", fib_result);
    
    // Test bubble sort
    int arr[] = {5, 2, 8, 1, 9, 3};
    int size = sizeof(arr) / sizeof(arr[0]);
    bubble_sort(arr, size);
    
    // Test string reverse
    char* reversed = reverse_string("hello world");
    printf("Reversed: %s\n", reversed);
    free(reversed);
    
    // Test pi calculation
    double pi = calculate_pi(1000);
    printf("Pi approximation: %f\n", pi);
    
    return 0;
}

// Recursive fibonacci function
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Bubble sort implementation
void bubble_sort(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// String reverse function
char* reverse_string(const char* str) {
    int len = strlen(str);
    char* reversed = malloc(len + 1);
    for (int i = 0; i < len; i++) {
        reversed[i] = str[len - 1 - i];
    }
    reversed[len] = '\0';
    return reversed;
}

// Pi calculation function
double calculate_pi(int iterations) {
    double pi = 0.0;
    for (int i = 0; i < iterations; i++) {
        pi += 4.0 / (2 * i + 1) * (i % 2 == 0 ? 1 : -1);
    }
    return pi;
}

// Static function (should not be visible in some contexts)
static int internal_helper() {
    return 42;
}
)";

        // Compile with extensive debug info
        test_executable = test_dir / "complex_test";
        std::string compile_cmd = "gcc -g3 -O0 -fno-omit-frame-pointer -Wall -Wextra -o " +
                                  test_executable.string() + " " + test_source.string() +
                                  " 2>/dev/null";
        int compile_result = system(compile_cmd.c_str());
        (void)compile_result; // Suppress unused variable warning

        // Create object file with debug info
        test_object = test_dir / "complex_test.o";
        std::string obj_compile_cmd = "gcc -c -g3 -O0 -fno-omit-frame-pointer -Wall -Wextra -o " +
                                      test_object.string() + " " + test_source.string() +
                                      " 2>/dev/null";
        int obj_compile_result = system(obj_compile_cmd.c_str());
        (void)obj_compile_result; // Suppress unused variable warning

        // Create shared library with debug info
        test_library = test_dir / "libcomplex.so";
        std::string lib_compile_cmd =
            "gcc -shared -fPIC -g3 -O0 -fno-omit-frame-pointer -Wall -Wextra -o " +
            test_library.string() + " " + test_source.string() + " 2>/dev/null";
        int lib_compile_result = system(lib_compile_cmd.c_str());
        (void)lib_compile_result; // Suppress unused variable warning

        // Fallback to dummy files if compilation fails
        if (!std::filesystem::exists(test_executable)) {
            std::ofstream(test_executable) << "dummy executable";
        }
        if (!std::filesystem::exists(test_object)) {
            std::ofstream(test_object) << "dummy object";
        }
        if (!std::filesystem::exists(test_library)) {
            std::ofstream(test_library) << "dummy library";
        }
    }

    void TearDown() override {
        std::filesystem::remove_all(test_dir);
    }

    std::filesystem::path test_dir;
    std::filesystem::path test_source;
    std::filesystem::path test_executable;
    std::filesystem::path test_object;
    std::filesystem::path test_library;
};

// Advanced Function Extraction Tests
TEST_F(DWARFAdvancedTest, DetailedFunctionExtraction) {
    DWARFExtractor extractor;
    std::vector<std::string> functions;

    if (std::filesystem::file_size(test_executable) > 100) {
        bool result = extractor.extractFunctions(test_executable.string(), functions);

        if (result) {
            EXPECT_FALSE(functions.empty());

            // Check for specific functions we know should be there
            std::vector<std::string> expected_functions = {"main", "fibonacci", "bubble_sort",
                                                           "reverse_string", "calculate_pi"};

            for (const auto& expected : expected_functions) {
                bool found = false;
                for (const auto& func : functions) {
                    if (func.find(expected) != std::string::npos) {
                        found = true;
                        break;
                    }
                }
                EXPECT_TRUE(found) << "Expected function '" << expected << "' not found";
            }

            // Verify we don't have internal helper functions (static)
            bool found_internal = false;
            for (const auto& func : functions) {
                if (func.find("internal_helper") != std::string::npos) {
                    found_internal = true;
                    break;
                }
            }
            // Note: Some DWARF implementations might include static functions
            // This is implementation-dependent
        }
    }
}

TEST_F(DWARFAdvancedTest, FunctionExtractionFromObjectFile) {
    DWARFExtractor extractor;
    std::vector<std::string> functions;

    if (std::filesystem::file_size(test_object) > 100) {
        bool result = extractor.extractFunctions(test_object.string(), functions);

        if (result) {
            EXPECT_FALSE(functions.empty());

            // Object files should contain the same functions
            std::vector<std::string> expected_functions = {"main", "fibonacci", "bubble_sort",
                                                           "reverse_string", "calculate_pi"};

            for (const auto& expected : expected_functions) {
                bool found = false;
                for (const auto& func : functions) {
                    if (func.find(expected) != std::string::npos) {
                        found = true;
                        break;
                    }
                }
                EXPECT_TRUE(found)
                    << "Expected function '" << expected << "' not found in object file";
            }
        }
    }
}

TEST_F(DWARFAdvancedTest, FunctionExtractionFromSharedLibrary) {
    DWARFExtractor extractor;
    std::vector<std::string> functions;

    if (std::filesystem::file_size(test_library) > 100) {
        bool result = extractor.extractFunctions(test_library.string(), functions);

        if (result) {
            EXPECT_FALSE(functions.empty());

            // Shared libraries should contain the same functions
            std::vector<std::string> expected_functions = {"main", "fibonacci", "bubble_sort",
                                                           "reverse_string", "calculate_pi"};

            for (const auto& expected : expected_functions) {
                bool found = false;
                for (const auto& func : functions) {
                    if (func.find(expected) != std::string::npos) {
                        found = true;
                        break;
                    }
                }
                EXPECT_TRUE(found)
                    << "Expected function '" << expected << "' not found in shared library";
            }
        }
    }
}

// Advanced Line Info Tests
TEST_F(DWARFAdvancedTest, DetailedLineInfoExtraction) {
    DWARFExtractor extractor;
    std::vector<std::string> lineInfo;

    if (std::filesystem::file_size(test_executable) > 100) {
        bool result = extractor.extractLineInfo(test_executable.string(), lineInfo);

        if (result) {
            EXPECT_FALSE(lineInfo.empty());

            // Verify line numbers are numeric
            for (const auto& line : lineInfo) {
                EXPECT_TRUE(std::all_of(line.begin(), line.end(), ::isdigit))
                    << "Line info should contain numeric values: " << line;
            }

            // Verify we have reasonable line numbers (should be > 0)
            for (const auto& line : lineInfo) {
                int lineNum = std::stoi(line);
                EXPECT_GT(lineNum, 0) << "Line number should be positive: " << lineNum;
            }
        }
    }
}

// Error Scenario Tests
TEST_F(DWARFAdvancedTest, CorruptedFileHandling) {
    DWARFExtractor extractor;
    std::vector<std::string> result;

    // Create a corrupted ELF file
    std::filesystem::path corrupted_file = test_dir / "corrupted.elf";
    std::ofstream(corrupted_file, std::ios::binary) << "This is not a valid ELF file";

    // All operations should fail gracefully
    EXPECT_FALSE(extractor.extractSourceFiles(corrupted_file.string(), result));
    EXPECT_TRUE(result.empty());

    result.clear();
    EXPECT_FALSE(extractor.extractCompileUnits(corrupted_file.string(), result));
    EXPECT_TRUE(result.empty());

    result.clear();
    EXPECT_FALSE(extractor.extractFunctions(corrupted_file.string(), result));
    EXPECT_TRUE(result.empty());

    result.clear();
    EXPECT_FALSE(extractor.extractLineInfo(corrupted_file.string(), result));
    EXPECT_TRUE(result.empty());

    EXPECT_FALSE(extractor.hasDWARFInfo(corrupted_file.string()));
}

TEST_F(DWARFAdvancedTest, TruncatedFileHandling) {
    DWARFExtractor extractor;
    std::vector<std::string> result;

    if (std::filesystem::file_size(test_executable) > 100) {
        // Create a truncated copy of the executable
        std::filesystem::path truncated_file = test_dir / "truncated.elf";
        std::ifstream src(test_executable, std::ios::binary);
        std::ofstream dst(truncated_file, std::ios::binary);

        // Copy only first 1000 bytes
        char buffer[1000];
        src.read(buffer, sizeof(buffer));
        dst.write(buffer, src.gcount());

        // Operations should fail gracefully
        EXPECT_FALSE(extractor.extractSourceFiles(truncated_file.string(), result));
        EXPECT_TRUE(result.empty());

        result.clear();
        EXPECT_FALSE(extractor.extractCompileUnits(truncated_file.string(), result));
        EXPECT_TRUE(result.empty());

        result.clear();
        EXPECT_FALSE(extractor.extractFunctions(truncated_file.string(), result));
        EXPECT_TRUE(result.empty());

        result.clear();
        EXPECT_FALSE(extractor.extractLineInfo(truncated_file.string(), result));
        EXPECT_TRUE(result.empty());

        EXPECT_FALSE(extractor.hasDWARFInfo(truncated_file.string()));
    }
}

TEST_F(DWARFAdvancedTest, NonExistentFileHandling) {
    DWARFExtractor extractor;
    std::vector<std::string> result;

    // Test with various non-existent paths
    std::vector<std::string> non_existent_paths = {
        "/nonexistent/path/file.elf", "relative/nonexistent/file.so", "", "   ",
        std::string(1000, 'a')  // Very long path
    };

    for (const auto& path : non_existent_paths) {
        EXPECT_FALSE(extractor.extractSourceFiles(path, result));
        EXPECT_TRUE(result.empty());

        result.clear();
        EXPECT_FALSE(extractor.extractCompileUnits(path, result));
        EXPECT_TRUE(result.empty());

        result.clear();
        EXPECT_FALSE(extractor.extractFunctions(path, result));
        EXPECT_TRUE(result.empty());

        result.clear();
        EXPECT_FALSE(extractor.extractLineInfo(path, result));
        EXPECT_TRUE(result.empty());

        EXPECT_FALSE(extractor.hasDWARFInfo(path));
    }
}

TEST_F(DWARFAdvancedTest, PermissionDeniedHandling) {
    DWARFExtractor extractor;
    std::vector<std::string> result;

    // Create a file with no read permissions
    std::filesystem::path no_permission_file = test_dir / "no_permission.elf";
    std::ofstream(no_permission_file) << "dummy content";
    std::filesystem::permissions(no_permission_file, std::filesystem::perms::none);

    // Operations should fail gracefully
    EXPECT_FALSE(extractor.extractSourceFiles(no_permission_file.string(), result));
    EXPECT_TRUE(result.empty());

    result.clear();
    EXPECT_FALSE(extractor.extractCompileUnits(no_permission_file.string(), result));
    EXPECT_TRUE(result.empty());

    result.clear();
    EXPECT_FALSE(extractor.extractFunctions(no_permission_file.string(), result));
    EXPECT_TRUE(result.empty());

    result.clear();
    EXPECT_FALSE(extractor.extractLineInfo(no_permission_file.string(), result));
    EXPECT_TRUE(result.empty());

    EXPECT_FALSE(extractor.hasDWARFInfo(no_permission_file.string()));

    // Restore permissions for cleanup
    std::filesystem::permissions(no_permission_file, std::filesystem::perms::owner_read |
                                                         std::filesystem::perms::owner_write);
}

// Performance and Stress Tests
TEST_F(DWARFAdvancedTest, LargeFilePerformance) {
    DWARFExtractor extractor;
    std::vector<std::string> result;

    if (std::filesystem::file_size(test_executable) > 100) {
        auto start = std::chrono::high_resolution_clock::now();

        bool success = extractor.extractSourceFiles(test_executable.string(), result);

        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

        // Should complete within reasonable time (5 seconds for small files)
        EXPECT_LT(duration.count(), 5000)
            << "DWARF extraction took too long: " << duration.count() << "ms";

        if (success) {
            EXPECT_FALSE(result.empty());
        }
    }
}

// NOTE: Concurrent DWARF extraction tests have been removed due to LLVM thread-safety limitations.
// LLVM's DWARF libraries are not designed for concurrent use and will cause segmentation faults
// when multiple DWARFExtractor instances are used simultaneously or when rapidly
// constructed/destroyed. See heimdall-limitations.md for details.

TEST_F(DWARFAdvancedTest, MemoryStressTest) {
    const int num_iterations = 100;
    std::vector<std::unique_ptr<DWARFExtractor>> extractors;

    if (std::filesystem::file_size(test_executable) > 100) {
        for (int i = 0; i < num_iterations; ++i) {
            auto extractor = std::make_unique<DWARFExtractor>();
            std::vector<std::string> result;

            bool success = extractor->extractSourceFiles(test_executable.string(), result);
            EXPECT_TRUE(success || !success);  // Should not crash

            extractors.push_back(std::move(extractor));

            // Clear some extractors periodically to test cleanup
            if (i % 10 == 0) {
                extractors.clear();
            }
        }

        // Final extraction should still work
        DWARFExtractor final_extractor;
        std::vector<std::string> result;
        bool success = final_extractor.extractSourceFiles(test_executable.string(), result);
        EXPECT_TRUE(success || !success);  // Should not crash
    }
}

// Cross-Platform Tests
TEST_F(DWARFAdvancedTest, PlatformSpecificBehavior) {
    DWARFExtractor extractor;
    std::vector<std::string> result;

    if (std::filesystem::file_size(test_executable) > 100) {
        bool success = extractor.extractSourceFiles(test_executable.string(), result);

        // On Linux with LLVM DWARF support, this should work
        // On other platforms, it might fall back to heuristic parsing
        if (success) {
            EXPECT_FALSE(result.empty());

            // Verify source files contain expected patterns
            bool found_source_file = false;
            for (const auto& file : result) {
                if (file.find("complex_test.c") != std::string::npos) {
                    found_source_file = true;
                    break;
                }
            }
            EXPECT_TRUE(found_source_file) << "Expected source file not found in extraction";
        }
    }
}

// Integration Tests
TEST_F(DWARFAdvancedTest, MetadataExtractorIntegration) {
    MetadataExtractor extractor;
    ComponentInfo component("complex_test", test_executable.string());

    if (std::filesystem::file_size(test_executable) > 100) {
        bool result = extractor.extractDebugInfo(component);

        // Should either succeed or fail gracefully
        EXPECT_TRUE(result || !result);

        if (result) {
            EXPECT_TRUE(component.containsDebugInfo);
            EXPECT_FALSE(component.sourceFiles.empty());
        }
    }
}

TEST_F(DWARFAdvancedTest, MetadataHelpersIntegration) {
    if (std::filesystem::file_size(test_executable) > 100) {
        // Test MetadataHelpers::extractDebugInfo
        ComponentInfo component("complex_test", test_executable.string());
        bool result = MetadataHelpers::extractDebugInfo(test_executable.string(), component);

        if (result) {
            EXPECT_TRUE(component.containsDebugInfo);
            EXPECT_FALSE(component.sourceFiles.empty());
        }

        // Test MetadataHelpers::extractSourceFiles
        std::vector<std::string> sourceFiles;
        bool source_result =
            MetadataHelpers::extractSourceFiles(test_executable.string(), sourceFiles);

        if (source_result) {
            EXPECT_FALSE(sourceFiles.empty());
        }

        // Test MetadataHelpers::extractCompileUnits
        std::vector<std::string> compileUnits;
        bool unit_result =
            MetadataHelpers::extractCompileUnits(test_executable.string(), compileUnits);

        if (unit_result) {
            EXPECT_FALSE(compileUnits.empty());
        }
    }
}

// End-to-End Tests
TEST_F(DWARFAdvancedTest, EndToEndSBOMGeneration) {
    if (std::filesystem::file_size(test_executable) > 100) {
        MetadataExtractor extractor;
        ComponentInfo component("complex_test", test_executable.string());

        // Extract all metadata including debug info
        bool result = extractor.extractMetadata(component);

        if (result) {
            // Verify debug info was extracted
            EXPECT_TRUE(component.wasProcessed);

            // If debug info extraction was enabled and successful
            if (component.containsDebugInfo) {
                EXPECT_FALSE(component.sourceFiles.empty());

                // Verify we have source files
                bool found_source = false;
                for (const auto& source : component.sourceFiles) {
                    if (source.find("complex_test.c") != std::string::npos) {
                        found_source = true;
                        break;
                    }
                }
                EXPECT_TRUE(found_source) << "Expected source file not found in SBOM";
            }
        }
    }
}

// Heuristic Fallback Tests
TEST_F(DWARFAdvancedTest, HeuristicFallbackBehavior) {
    DWARFExtractor extractor;
    std::vector<std::string> result;

    // Create a file with debug info but potentially corrupted DWARF
    std::filesystem::path fallback_file = test_dir / "fallback_test.elf";

    if (std::filesystem::file_size(test_executable) > 100) {
        // Copy the executable to test fallback behavior
        std::filesystem::copy_file(test_executable, fallback_file);

        std::vector<std::string> sourceFiles;
        bool result = extractor.extractSourceFiles(fallback_file.string(), sourceFiles);

        // Should either succeed with LLVM DWARF or fall back to heuristic
        // Both cases are valid
        if (result) {
            EXPECT_FALSE(sourceFiles.empty());
        }
    }
}

// Memory Leak Tests
TEST_F(DWARFAdvancedTest, MemoryLeakStressTest) {
    const int num_iterations = 50;

    if (std::filesystem::file_size(test_executable) > 100) {
        for (int i = 0; i < num_iterations; ++i) {
            {
                DWARFExtractor extractor;
                std::vector<std::string> sourceFiles, functions, compileUnits, lineInfo;

                // Perform all extraction operations
                extractor.extractSourceFiles(test_executable.string(), sourceFiles);
                extractor.extractFunctions(test_executable.string(), functions);
                extractor.extractCompileUnits(test_executable.string(), compileUnits);
                extractor.extractLineInfo(test_executable.string(), lineInfo);
                extractor.hasDWARFInfo(test_executable.string());
            }
            // DWARFExtractor should be destroyed here, no memory leaks
        }

        // Final extraction should still work
        DWARFExtractor final_extractor;
        std::vector<std::string> result;
        bool success = final_extractor.extractSourceFiles(test_executable.string(), result);
        EXPECT_TRUE(success || !success);  // Should not crash
    }
}

// Boundary Condition Tests
TEST_F(DWARFAdvancedTest, EmptyVectorHandling) {
    DWARFExtractor extractor;
    std::vector<std::string> empty_result;

    if (std::filesystem::file_size(test_executable) > 100) {
        // Test that functions handle empty vectors correctly
        bool success = extractor.extractSourceFiles(test_executable.string(), empty_result);

        if (success) {
            EXPECT_FALSE(empty_result.empty());
        }

        // Test with pre-populated vector
        std::vector<std::string> pre_populated = {"existing_item"};
        size_t initial_size = pre_populated.size();
        bool success2 = extractor.extractSourceFiles(test_executable.string(), pre_populated);

        if (success2) {
            // Should either have more items or at least the same number
            EXPECT_GE(pre_populated.size(), initial_size);
        }
        // If success2 is false, that's also acceptable - the file might not have debug info
    }
}

TEST_F(DWARFAdvancedTest, LargeOutputVectorHandling) {
    DWARFExtractor extractor;

    if (std::filesystem::file_size(test_executable) > 100) {
        // Test with very large pre-allocated vector
        std::vector<std::string> large_vector;
        large_vector.reserve(10000);

        bool success = extractor.extractSourceFiles(test_executable.string(), large_vector);

        if (success) {
            EXPECT_FALSE(large_vector.empty());
        }
    }
}

}  // namespace heimdall