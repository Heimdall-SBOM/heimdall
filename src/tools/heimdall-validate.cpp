/**
 * @file heimdall-validate.cpp
 * @brief Command-line tool for validating, comparing, merging, and diffing SBOM files (SPDX,
 * CycloneDX)
 * @author Trevor Bakker
 * @date 2025
 *
 * This tool provides validation and comparison utilities for SBOMs generated by Heimdall.
 * It supports SPDX and CycloneDX formats, and can validate, compare, merge, and diff SBOM files.
 */
#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <vector>
#include "../common/SBOMComparator.hpp"
#include "../common/SBOMValidator.hpp"
#include "../common/SBOMSigner.hpp"

using namespace heimdall;

/**
 * @brief Print usage information for the heimdall-validate tool
 * @param programName The name of the executable
 */
void printUsage(const char* programName)
{
   std::cout << "Heimdall SBOM Validation and Comparison Tool\n\n";
   std::cout << "Usage: " << programName << " <command> [options]\n\n";
   std::cout << "Commands:\n";
   std::cout << "  validate <file> [--format <format>]     Validate an SBOM file\n";
   std::cout << "  verify-signature <file> [--key <key>] [--cert <cert>] Verify SBOM signature\n";
   std::cout << "  compare <old> <new> [--format <format>] Compare two SBOM files\n";
   std::cout << "  merge <files...> --output <file>        Merge multiple SBOMs\n";
   std::cout << "  diff <old> <new> [--format <format>]    Generate diff report\n\n";
   std::cout << "Options:\n";
   std::cout << "  --format <format>    SBOM format (spdx, cyclonedx) [auto-detect]\n";
   std::cout << "  --output <file>      Output file for merge command\n";
   std::cout << "  --report-format <f>  Diff report format (text, json, csv) [text]\n";
   std::cout << "  --verbose            Verbose output\n";
   std::cout << "  --help               Show this help message\n\n";
   std::cout << "Signature Verification:\n";
   std::cout << "  --key <key>          Path to public key file for signature verification\n";
   std::cout << "  --cert <cert>        Path to certificate file for signature verification\n";
   std::cout << "                       Either --key or --cert must be specified for verify-signature\n\n";
   std::cout << "Examples:\n";
   std::cout << "  # Validate SBOM format and content\n";
   std::cout << "  " << programName << " validate sbom.spdx\n";
   std::cout << "  " << programName << " validate sbom.cdx.json --format cyclonedx\n\n";
   std::cout << "  # Verify signature using public key\n";
   std::cout << "  " << programName << " verify-signature sbom.cdx.json --key public.key\n\n";
   std::cout << "  # Verify signature using certificate\n";
   std::cout << "  " << programName << " verify-signature sbom.cdx.json --cert certificate.pem\n\n";
   std::cout << "  # Compare two SBOM files\n";
   std::cout << "  " << programName << " compare old.spdx new.spdx\n";
   std::cout << "  " << programName << " compare old.cdx.json new.cdx.json --format cyclonedx\n\n";
   std::cout << "  # Merge multiple SBOMs\n";
   std::cout << "  " << programName << " merge sbom1.json sbom2.json --output merged.json\n\n";
   std::cout << "  # Generate diff report\n";
   std::cout << "  " << programName << " diff old.spdx new.spdx --report-format json\n";
   std::cout << "  " << programName << " diff old.cdx.json new.cdx.json --report-format csv\n\n";
   std::cout << "Notes:\n";
   std::cout << "  - Signature verification supports JSF (JSON Signature Format) compliant signatures\n";
   std::cout << "  - Supported signature algorithms: RS256, RS384, RS512, ES256, ES384, ES512, Ed25519\n";
   std::cout << "  - Public key files should be in PEM format\n";
   std::cout << "  - Certificate files should be in PEM format\n";
   std::cout << "  - Format auto-detection works for common file extensions (.spdx, .cdx.json, .json)\n";
}

/**
 * @brief Detect the SBOM format (spdx or cyclonedx) from a file path
 * @param filePath The path to the SBOM file
 * @return The detected format as a string ("spdx", "cyclonedx", or empty if unknown)
 */
std::string detectFormat(const std::string& filePath)
{
   std::ifstream file(filePath);
   if (!file.is_open())
   {
      return "";
   }

   std::string firstLine;
   std::getline(file, firstLine);

   if (firstLine.find("SPDXVersion:") != std::string::npos)
   {
      return "spdx";
   }
   else if (firstLine.find('{') != std::string::npos)
   {
      // Read more to determine if it's SPDX 3.0 or CycloneDX
      std::string content;
      file.seekg(0);
      std::stringstream buffer;
      buffer << file.rdbuf();
      content = buffer.str();

      if (content.find("\"spdxVersion\"") != std::string::npos)
      {
         return "spdx";
      }
      else if (content.find("\"bomFormat\"") != std::string::npos)
      {
         return "cyclonedx";
      }
   }

   return "";
}

/**
 * @brief Validate an SBOM file using the specified or auto-detected format
 * @param args Command-line arguments (expects args[1] to be the file path)
 * @return 0 if valid, 1 if invalid or error
 */
int validateCommand(const std::vector<std::string>& args)
{
   if (args.size() < 2)
   {
      std::cerr << "Error: validate command requires a file path\n";
      return 1;
   }

   std::string filePath = args[1];
   std::string format;
   std::string version;

   // Parse options
   for (size_t i = 2; i < args.size(); ++i)
   {
      if (args[i] == "--format" && i + 1 < args.size())
      {
         format = args[++i];
      }
      else if (args[i] == "--version" && i + 1 < args.size())
      {
         version = args[++i];
      }
      else if (args[i] == "--help")
      {
         printUsage("heimdall-validate");
         return 0;
      }
   }

   // Auto-detect format if not specified
   if (format.empty())
   {
      format = detectFormat(filePath);
      if (format.empty())
      {
         std::cerr << "Error: Cannot auto-detect SBOM format. Please specify with --format\n";
         return 1;
      }
   }

   // Create validator
   auto validator = SBOMValidatorFactory::createValidator(format);
   if (!validator)
   {
      std::cerr << "Error: Unsupported format: " << format << "\n";
      return 1;
   }

   // Validate
   std::cout << "Validating " << filePath << " (" << format;
   if (!version.empty())
      std::cout << ", version " << version;
   std::cout << " format)...\n";

   heimdall::ValidationResult result;
   if (!version.empty())
   {
      // Use version-specific validation if supported
      // Only CycloneDXValidator and SPDXValidator support this
      if (format == "cyclonedx" || format == "cyclone")
      {
         auto* cyclonedx = dynamic_cast<heimdall::CycloneDXValidator*>(validator.get());
         if (cyclonedx)
         {
            result = cyclonedx->validate(filePath, version);
         }
         else
         {
            result = validator->validate(filePath);
         }
      }
      else if (format == "spdx")
      {
         auto* spdx = dynamic_cast<heimdall::SPDXValidator*>(validator.get());
         if (spdx)
         {
            result = spdx->validate(filePath, version);
         }
         else
         {
            result = validator->validate(filePath);
         }
      }
      else
      {
         result = validator->validate(filePath);
      }
   }
   else
   {
      result = validator->validate(filePath);
   }

   // Print results
   std::cout << "\nValidation Results:\n";
   std::cout << "==================\n";
   std::cout << "Valid: " << (result.isValid ? "Yes" : "No") << "\n";
   std::cout << "Format: " << result.metadata["format"] << "\n";
   std::cout << "Version: " << result.metadata["version"] << "\n\n";

   if (!result.errors.empty())
   {
      std::cout << "Errors:\n";
      for (const auto& error : result.errors)
      {
         std::cout << "  ❌ " << error << "\n";
      }
      std::cout << "\n";
   }

   if (!result.warnings.empty())
   {
      std::cout << "Warnings:\n";
      for (const auto& warning : result.warnings)
      {
         std::cout << "  ⚠️  " << warning << "\n";
      }
      std::cout << "\n";
   }

   return result.isValid ? 0 : 1;
}

/**
 * @brief Verify signature in an SBOM file
 * @param args Command-line arguments (expects args[1] to be the file path)
 * @return 0 if signature is valid, 1 if invalid or error
 */
int verifySignatureCommand(const std::vector<std::string>& args)
{
   if (args.size() < 2)
   {
      std::cerr << "Error: verify-signature command requires a file path\n";
      return 1;
   }

   std::string filePath = args[1];
   std::string keyPath;
   std::string certPath;

   // Parse options
   for (size_t i = 2; i < args.size(); ++i)
   {
      if (args[i] == "--key" && i + 1 < args.size())
      {
         keyPath = args[++i];
      }
      else if (args[i] == "--cert" && i + 1 < args.size())
      {
         certPath = args[++i];
      }
      else if (args[i] == "--help")
      {
         printUsage("heimdall-validate");
         return 0;
      }
   }

   // Check if we have a key or certificate
   if (keyPath.empty() && certPath.empty())
   {
      std::cerr << "Error: Must specify either --key or --cert for signature verification\n";
      return 1;
   }

   // Read the SBOM file
   std::ifstream file(filePath);
   if (!file.is_open())
   {
      std::cerr << "Error: Cannot open file: " << filePath << "\n";
      return 1;
   }

   std::string sbomContent((std::istreambuf_iterator<char>(file)),
                          std::istreambuf_iterator<char>());
   file.close();

   // Create signer and load public key
   SBOMSigner signer;
   bool keyLoaded = false;

   if (!keyPath.empty())
   {
      if (signer.loadPublicKey(keyPath))
      {
         keyLoaded = true;
         std::cout << "Loaded public key from: " << keyPath << "\n";
      }
      else
      {
         std::cerr << "Error loading public key: " << signer.getLastError() << "\n";
      }
   }

   if (!certPath.empty() && !keyLoaded)
   {
      if (signer.loadPublicKeyFromCertificate(certPath))
      {
         keyLoaded = true;
         std::cout << "Loaded public key from certificate: " << certPath << "\n";
      }
      else
      {
         std::cerr << "Error loading certificate: " << signer.getLastError() << "\n";
      }
   }

   if (!keyLoaded)
   {
      std::cerr << "Error: Failed to load public key for verification\n";
      return 1;
   }

   // Verify signature
   std::cout << "Verifying signature in " << filePath << "...\n";

   if (signer.verifySignature(sbomContent))
   {
      std::cout << "\nSignature Verification Results:\n";
      std::cout << "==============================\n";
      std::cout << "✅ Signature is VALID\n\n";

      // Extract and display signature information
      SignatureInfo signatureInfo;
      if (signer.extractSignature(sbomContent, signatureInfo))
      {
         std::cout << "Signature Details:\n";
         std::cout << "  Algorithm: " << signatureInfo.algorithm << "\n";
         if (!signatureInfo.keyId.empty())
         {
            std::cout << "  Key ID: " << signatureInfo.keyId << "\n";
         }
         if (!signatureInfo.timestamp.empty())
         {
            std::cout << "  Timestamp: " << signatureInfo.timestamp << "\n";
         }
         if (!signatureInfo.excludes.empty())
         {
            std::cout << "  Excluded fields: ";
            for (size_t i = 0; i < signatureInfo.excludes.size(); ++i)
            {
               if (i > 0) std::cout << ", ";
               std::cout << signatureInfo.excludes[i];
            }
            std::cout << "\n";
         }
      }
   }
   else
   {
      std::cout << "\nSignature Verification Results:\n";
      std::cout << "==============================\n";
      std::cout << "❌ Signature is INVALID\n";
      std::cout << "Error: " << signer.getLastError() << "\n";
      return 1;
   }

   return 0;
}

/**
 * @brief Get a symbol and message describing a difference between SBOMs
 * @param diff The SBOMDifference object
 * @return A pair of (symbol, message) strings
 */
std::pair<std::string, std::string> getDifferenceInfo(const SBOMDifference& diff)
{
   std::string symbol;
   std::string message;

   switch (diff.type)
   {
      case SBOMDifference::Type::ADDED:
         symbol  = "➕";
         message = "Added: " + diff.component.name + " (" + diff.component.id + ")";
         break;
      case SBOMDifference::Type::REMOVED:
         symbol  = "➖";
         message = "Removed: " + diff.component.name + " (" + diff.component.id + ")";
         break;
      case SBOMDifference::Type::MODIFIED:
         symbol  = "🔄";
         message = "Modified: " + diff.component.name + " (" + diff.component.id + ")";
         if (diff.oldComponent.has_value())
         {
            message +=
               ", previous: " + diff.oldComponent->name + " (" + diff.oldComponent->id + ")";
         }
         break;
      case SBOMDifference::Type::UNCHANGED:
         symbol  = "✅";
         message = "Unchanged: " + diff.component.name + " (" + diff.component.id + ")";
         break;
   }

   return {symbol, message};
}

/**
 * @brief Print detailed differences between SBOMs
 * @param differences Vector of SBOMDifference objects
 */
void printDetailedDifferences(const std::vector<SBOMDifference>& differences)
{
   if (differences.empty())
   {
      std::cout << "No differences found.\n";
      return;
   }

   std::cout << "Detailed Differences:\n";
   for (const auto& diff : differences)
   {
      std::pair<std::string, std::string> info = getDifferenceInfo(diff);
      std::cout << "  " << info.first << " " << info.second << "\n";
   }
}

/**
 * @brief Compare two SBOM files and print the differences
 * @param args Command-line arguments (expects args[1] and args[2] to be file paths)
 * @return 0 if successful, 1 if error
 */
int compareCommand(const std::vector<std::string>& args)
{
   if (args.size() < 3)
   {
      std::cerr << "Error: compare command requires two file paths\n";
      return 1;
   }

   std::string oldFile = args[1];
   std::string newFile = args[2];
   std::string format;

   // Parse options
   for (size_t i = 3; i < args.size(); ++i)
   {
      if (args[i] == "--format" && i + 1 < args.size())
      {
         format = args[++i];
      }
      else if (args[i] == "--help")
      {
         printUsage("heimdall-validate");
         return 0;
      }
   }

   // Auto-detect format if not specified
   if (format.empty())
   {
      format = detectFormat(oldFile);
      if (format.empty())
      {
         std::cerr << "Error: Cannot auto-detect SBOM format. Please specify with --format\n";
         return 1;
      }
   }

   // Create comparator
   SBOMComparator comparator;

   // Compare
   std::cout << "Comparing " << oldFile << " and " << newFile << " (" << format << " format)...\n";
   auto differences = comparator.compare(oldFile, newFile);

   // Print results
   std::cout << "\nComparison Results:\n";
   std::cout << "==================\n";

   auto stats = comparator.getDiffStatistics(differences);
   std::cout << "Total differences: " << differences.size() << "\n";
   std::cout << "Added: " << stats["added"] << "\n";
   std::cout << "Removed: " << stats["removed"] << "\n";
   std::cout << "Modified: " << stats["modified"] << "\n";
   std::cout << "Unchanged: " << stats["unchanged"] << "\n\n";

   printDetailedDifferences(differences);

   return 0;
}

/**
 * @brief Generate a diff report between two SBOM files
 * @param args Command-line arguments (expects args[1] and args[2] to be file paths)
 * @return 0 if successful, 1 if error
 */
int diffCommand(const std::vector<std::string>& args)
{
   if (args.size() < 3)
   {
      std::cerr << "Error: diff command requires two file paths\n";
      return 1;
   }

   std::string oldFile = args[1];
   std::string newFile = args[2];
   std::string format;
   std::string reportFormat = "text";

   // Parse options
   for (size_t i = 3; i < args.size(); ++i)
   {
      if (args[i] == "--format" && i + 1 < args.size())
      {
         format = args[++i];
      }
      else if (args[i] == "--report-format" && i + 1 < args.size())
      {
         reportFormat = args[++i];
      }
      else if (args[i] == "--help")
      {
         printUsage("heimdall-validate");
         return 0;
      }
   }

   // Auto-detect format if not specified
   if (format.empty())
   {
      format = detectFormat(oldFile);
      if (format.empty())
      {
         std::cerr << "Error: Cannot auto-detect SBOM format. Please specify with --format\n";
         return 1;
      }
   }

   // Create comparator
   SBOMComparator comparator;

   // Compare
   std::cout << "Generating diff report for " << oldFile << " and " << newFile << "...\n";
   auto differences = comparator.compare(oldFile, newFile);

   // Generate report
   std::string report = comparator.generateDiffReport(differences, reportFormat);
   std::cout << report;

   return 0;
}

/**
 * @brief Merge multiple SBOM files into one
 * @param args Command-line arguments (expects file paths and --output option)
 * @return 0 if successful, 1 if error
 */
int mergeCommand(const std::vector<std::string>& args)
{
   if (args.size() < 2)
   {
      std::cerr << "Error: merge command requires at least one input file\n";
      return 1;
   }

   std::vector<std::string> inputFiles;
   std::string              outputFile;
   std::string              format  = "cyclonedx";
   std::string              version = "1.6";

   // Parse arguments
   for (size_t i = 1; i < args.size(); ++i)
   {
      if (args[i] == "--output" && i + 1 < args.size())
      {
         outputFile = args[++i];
      }
      else if (args[i] == "--format" && i + 1 < args.size())
      {
         format = args[++i];
      }
      else if (args[i] == "--version" && i + 1 < args.size())
      {
         version = args[++i];
      }
      else if (args[i] == "--help")
      {
         printUsage("heimdall-validate");
         return 0;
      }
      else if (args[i][0] != '-')
      {
         inputFiles.push_back(args[i]);
      }
   }

   if (inputFiles.empty())
   {
      std::cerr << "Error: No input files specified\n";
      return 1;
   }

   if (outputFile.empty())
   {
      std::cerr << "Error: Output file not specified (use --output)\n";
      return 1;
   }

   // Create comparator
   SBOMComparator comparator;

   // Merge
   std::cout << "Merging " << inputFiles.size() << " SBOM files...\n";
   std::string mergedContent = comparator.merge(inputFiles, format, version);

   // Write output
   std::ofstream output(outputFile);
   if (!output.is_open())
   {
      std::cerr << "Error: Cannot write to output file: " << outputFile << "\n";
      return 1;
   }

   output << mergedContent;
   output.close();

   std::cout << "Merged SBOM written to: " << outputFile << "\n";
   return 0;
}

/**
 * @brief Main entry point for the heimdall-validate tool
 * @param argc Argument count
 * @param argv Argument vector
 * @return Exit code
 */
int main(int argc, char* argv[])
{
   if (argc < 2)
   {
      printUsage(argv[0]);
      return 1;
   }

   std::string              command = argv[1];
   std::vector<std::string> args(argv + 1, argv + argc);

   if (command == "--help" || command == "-h")
   {
      printUsage(argv[0]);
      return 0;
   }
   else if (command == "validate")
   {
      return validateCommand(args);
   }
   else if (command == "verify-signature")
   {
      return verifySignatureCommand(args);
   }
   else if (command == "compare")
   {
      return compareCommand(args);
   }
   else if (command == "diff")
   {
      return diffCommand(args);
   }
   else if (command == "merge")
   {
      return mergeCommand(args);
   }
   else
   {
      std::cerr << "Error: Unknown command: " << command << "\n";
      printUsage(argv[0]);
      return 1;
   }
}