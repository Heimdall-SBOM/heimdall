/*
Copyright 2025 The Heimdall Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * @file heimdall-validate.cpp
 * @brief Command-line tool for validating, comparing, merging, and diffing SBOM files (SPDX,
 * CycloneDX)
 * @author Trevor Bakker
 * @date 2025
 *
 * This tool provides validation and comparison utilities for SBOMs generated by Heimdall.
 * It supports SPDX and CycloneDX formats, and can validate, compare, merge, and diff SBOM files.
 */
#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <vector>
#include "../common/SBOMComparator.hpp"
#include "../common/SBOMSigner.hpp"
#include "../common/SBOMValidator.hpp"

using namespace heimdall;

/**
 * @brief Print usage information for the heimdall-validate tool
 * @param programName The name of the executable
 */
void printUsage(const char* programName)
{
   std::cout << "Heimdall SBOM Validation and Comparison Tool\n\n";
   std::cout << "Usage: " << programName << " <command> [options]\n\n";
   std::cout << "Commands:\n";
   std::cout << "  validate <file> [--format <format>]     Validate an SBOM file\n";
   std::cout << "  verify-signature <file> [--key <key>] [--cert <cert>] Verify SBOM signature\n";
   std::cout << "  compare <old> <new> [--format <format>] Compare two SBOM files\n";
   std::cout << "  merge <files...> --output <file>        Merge multiple SBOMs\n";
   std::cout << "  diff <old> <new> [--format <format>]    Generate diff report\n\n";
   std::cout << "Options:\n";
   std::cout << "  --format <format>    SBOM format (spdx, cyclonedx) [auto-detect]\n";
   std::cout << "  --output <file>      Output file for merge command\n";
   std::cout << "  --report-format <f>  Diff report format (text, json, csv) [text]\n";
   std::cout << "  --verbose            Verbose output\n";
   std::cout << "  --help               Show this help message\n\n";
   std::cout << "Signature Verification:\n";
   std::cout << "  --key <key>          Path to public key file for signature verification\n";
   std::cout << "  --cert <cert>        Path to certificate file for signature verification\n";
   std::cout
      << "                       Either --key or --cert must be specified for verify-signature\n\n";
   std::cout << "Examples:\n";
   std::cout << "  # Validate SBOM format and content\n";
   std::cout << "  " << programName << " validate sbom.spdx\n";
   std::cout << "  " << programName << " validate sbom.cdx.json --format cyclonedx\n\n";
   std::cout << "  # Verify signature using public key\n";
   std::cout << "  " << programName << " verify-signature sbom.cdx.json --key public.key\n\n";
   std::cout << "  # Verify signature using certificate\n";
   std::cout << "  " << programName << " verify-signature sbom.cdx.json --cert certificate.pem\n\n";
   std::cout << "  # Compare two SBOM files\n";
   std::cout << "  " << programName << " compare old.spdx new.spdx\n";
   std::cout << "  " << programName << " compare old.cdx.json new.cdx.json --format cyclonedx\n\n";
   std::cout << "  # Merge multiple SBOMs\n";
   std::cout << "  " << programName << " merge sbom1.json sbom2.json --output merged.json\n\n";
   std::cout << "  # Generate diff report\n";
   std::cout << "  " << programName << " diff old.spdx new.spdx --report-format json\n";
   std::cout << "  " << programName << " diff old.cdx.json new.cdx.json --report-format csv\n\n";
   std::cout << "Notes:\n";
   std::cout
      << "  - Signature verification supports JSF (JSON Signature Format) compliant signatures\n";
   std::cout
      << "  - Supported signature algorithms: RS256, RS384, RS512, ES256, ES384, ES512, Ed25519\n";
   std::cout << "  - Public key files should be in PEM format\n";
   std::cout << "  - Certificate files should be in PEM format\n";
   std::cout
      << "  - Format auto-detection works for common file extensions (.spdx, .cdx.json, .json)\n";
}

/**
 * @brief Detect the SBOM format (spdx or cyclonedx) from a file path
 * @param filePath The path to the SBOM file
 * @return The detected format as a string ("spdx", "cyclonedx", or empty if unknown)
 */
std::string detectFormat(const std::string& filePath)
{
   std::ifstream file(filePath);
   if (!file.is_open())
   {
      return "";
   }

   std::string firstLine;
   std::getline(file, firstLine);

   if (firstLine.find("SPDXVersion:") != std::string::npos)
   {
      return "spdx";
   }
   else if (firstLine.find('{') != std::string::npos)
   {
      // Read more to determine if it's SPDX 3.0 or CycloneDX
      std::string content;
      file.seekg(0);
      std::stringstream buffer;
      buffer << file.rdbuf();
      content = buffer.str();

      if (content.find("\"spdxVersion\"") != std::string::npos)
      {
         return "spdx";
      }
      else if (content.find("\"bomFormat\"") != std::string::npos)
      {
         return "cyclonedx";
      }
   }

   return "";
}

/**
 * @brief Validate an SBOM file using the specified or auto-detected format
 * @param args Command-line arguments (expects args[1] to be the file path)
 * @return 0 if valid, 1 if invalid or error
 */
int validateCommand(const std::vector<std::string>& args)
{
   if (args.size() < 2)
   {
      std::cerr << "Error: validate command requires a file path\n";
      return 1;
   }

   std::string filePath = args[1];
   std::string format;
   std::string version;

   // Parse options
   for (size_t i = 2; i < args.size(); ++i)
   {
      if (args[i] == "--format" && i + 1 < args.size())
      {
         format = args[++i];
      }
      else if (args[i] == "--version" && i + 1 < args.size())
      {
         version = args[++i];
      }
      else if (args[i] == "--help")
      {
         printUsage("heimdall-validate");
         return 0;
      }
   }

   // Auto-detect format if not specified
   if (format.empty())
   {
      format = detectFormat(filePath);
      if (format.empty())
      {
         std::cerr << "Error: Cannot auto-detect SBOM format. Please specify with --format\n";
         return 1;
      }
   }

   // Create validator
   auto validator = SBOMValidatorFactory::createValidator(format);
   if (!validator)
   {
      std::cerr << "Error: Unsupported format: " << format << "\n";
      return 1;
   }

   // Validate
   std::cout << "Validating " << filePath << " (" << format;
   if (!version.empty())
      std::cout << ", version " << version;
   std::cout << " format)...\n";

   heimdall::ValidationResult result;
   if (!version.empty())
   {
      // Use version-specific validation if supported
      // Only CycloneDXValidator and SPDXValidator support this
      if (format == "cyclonedx" || format == "cyclone")
      {
         auto* cyclonedx = dynamic_cast<heimdall::UnifiedSBOMValidator*>(validator.get());
         if (cyclonedx)
         {
            result = cyclonedx->validate(filePath);
         }
         else
         {
            result = validator->validate(filePath);
         }
      }
      else if (format == "spdx")
      {
         auto* spdx = dynamic_cast<heimdall::UnifiedSBOMValidator*>(validator.get());
         if (spdx)
         {
            result = spdx->validate(filePath);
         }
         else
         {
            result = validator->validate(filePath);
         }
      }
      else
      {
         result = validator->validate(filePath);
      }
   }
   else
   {
      result = validator->validate(filePath);
   }

   // Print results
   std::cout << "\nValidation Results:\n";
   std::cout << "==================\n";
   std::cout << "Valid: " << (result.isValid ? "Yes" : "No") << "\n";
   std::cout << "Format: " << result.metadata["format"] << "\n";
   std::cout << "Version: " << result.metadata["version"] << "\n\n";

   if (!result.errors.empty())
   {
      std::cout << "Errors:\n";
      for (const auto& error : result.errors)
      {
         std::cout << "  âŒ " << error << "\n";
      }
      std::cout << "\n";
   }

   if (!result.warnings.empty())
   {
      std::cout << "Warnings:\n";
      for (const auto& warning : result.warnings)
      {
         std::cout << "  âš ï¸  " << warning << "\n";
      }
      std::cout << "\n";
   }

   return result.isValid ? 0 : 1;
}

/**
 * @brief Verify signature in an SBOM file
 * @param args Command-line arguments (expects args[1] to be the file path)
 * @return 0 if signature is valid, 1 if invalid or error
 */
int verifySignatureCommand(const std::vector<std::string>& args)
{
   if (args.size() < 2)
   {
      std::cerr << "Error: verify-signature command requires a file path\n";
      return 1;
   }

   std::string filePath = args[1];
   std::string keyPath;
   std::string certPath;

   // Parse options
   for (size_t i = 2; i < args.size(); ++i)
   {
      if (args[i] == "--key" && i + 1 < args.size())
      {
         keyPath = args[++i];
      }
      else if (args[i] == "--cert" && i + 1 < args.size())
      {
         certPath = args[++i];
      }
      else if (args[i] == "--help")
      {
         printUsage("heimdall-validate");
         return 0;
      }
   }

   // Check if we have a key or certificate
   if (keyPath.empty() && certPath.empty())
   {
      std::cerr << "Error: Must specify either --key or --cert for signature verification\n";
      return 1;
   }

   // Read the SBOM file
   std::ifstream file(filePath);
   if (!file.is_open())
   {
      std::cerr << "Error: Cannot open file: " << filePath << "\n";
      return 1;
   }

   std::string sbomContent((std::istreambuf_iterator<char>(file)),
                           std::istreambuf_iterator<char>());
   file.close();

   // Create signer and load public key
   SBOMSigner signer;
   bool       keyLoaded = false;

   if (!keyPath.empty())
   {
      if (signer.loadPublicKey(keyPath))
      {
         keyLoaded = true;
         std::cout << "Loaded public key from: " << keyPath << "\n";
      }
      else
      {
         std::cerr << "Error loading public key: " << signer.getLastError() << "\n";
      }
   }

   if (!certPath.empty() && !keyLoaded)
   {
      if (signer.loadPublicKeyFromCertificate(certPath))
      {
         keyLoaded = true;
         std::cout << "Loaded public key from certificate: " << certPath << "\n";
      }
      else
      {
         std::cerr << "Error loading certificate: " << signer.getLastError() << "\n";
      }
   }

   if (!keyLoaded)
   {
      std::cerr << "Error: Failed to load public key for verification\n";
      return 1;
   }

   // Verify signature
   std::cout << "Verifying signature in " << filePath << "...\n";

   if (signer.verifySignature(sbomContent))
   {
      std::cout << "\nSignature Verification Results:\n";
      std::cout << "==============================\n";
      std::cout << "âœ… Signature is VALID\n\n";

      // Extract and display signature information
      SignatureInfo signatureInfo;
      if (signer.extractSignature(sbomContent, signatureInfo))
      {
         std::cout << "Signature Details:\n";
         std::cout << "  Algorithm: " << signatureInfo.algorithm << "\n";
         if (!signatureInfo.keyId.empty())
         {
            std::cout << "  Key ID: " << signatureInfo.keyId << "\n";
         }
         if (!signatureInfo.timestamp.empty())
         {
            std::cout << "  Timestamp: " << signatureInfo.timestamp << "\n";
         }
         if (!signatureInfo.excludes.empty())
         {
            std::cout << "  Excluded fields: ";
            for (size_t i = 0; i < signatureInfo.excludes.size(); ++i)
            {
               if (i > 0)
                  std::cout << ", ";
               std::cout << signatureInfo.excludes[i];
            }
            std::cout << "\n";
         }
      }
   }
   else
   {
      std::cout << "\nSignature Verification Results:\n";
      std::cout << "==============================\n";
      std::cout << "âŒ Signature is INVALID\n";
      std::cout << "Error: " << signer.getLastError() << "\n";
      return 1;
   }

   return 0;
}

/**
 * @brief Get a symbol and message describing a difference between SBOMs
 * @param diff The SBOMDifference object
 * @return A pair of (symbol, message) strings
 */
std::pair<std::string, std::string> getDifferenceInfo(const SBOMDifference& diff)
{
   std::string symbol;
   std::string message;

   switch (diff.type)
   {
      case SBOMDifference::Type::ADDED:
         symbol  = "âž•";
         message = "Added: " + diff.component.name + " (" + diff.component.id + ")";
         break;
      case SBOMDifference::Type::REMOVED:
         symbol  = "âž–";
         message = "Removed: " + diff.component.name + " (" + diff.component.id + ")";
         break;
      case SBOMDifference::Type::MODIFIED:
         symbol  = "ðŸ”„";
         message = "Modified: " + diff.component.name + " (" + diff.component.id + ")";
         if (diff.oldComponent.has_value())
         {
            message +=
               ", previous: " + diff.oldComponent->name + " (" + diff.oldComponent->id + ")";
         }
         break;
      case SBOMDifference::Type::UNCHANGED:
         symbol  = "âœ…";
         message = "Unchanged: " + diff.component.name + " (" + diff.component.id + ")";
         break;
   }

   return {symbol, message};
}

/**
 * @brief Print detailed differences between SBOMs
 * @param differences Vector of SBOMDifference objects
 */
void printDetailedDifferences(const std::vector<SBOMDifference>& differences)
{
   if (differences.empty())
   {
      std::cout << "No differences found.\n";
      return;
   }

   std::cout << "Detailed Differences:\n";
   for (const auto& diff : differences)
   {
      std::pair<std::string, std::string> info = getDifferenceInfo(diff);
      std::cout << "  " << info.first << " " << info.second << "\n";
   }
}

/**
 * @brief Compare two SBOM files and print the differences
 * @param args Command-line arguments (expects args[1] and args[2] to be file paths)
 * @return 0 if successful, 1 if error
 */
int compareCommand(const std::vector<std::string>& args)
{
   if (args.size() < 3)
   {
      std::cerr << "Error: compare command requires two file paths\n";
      return 1;
   }

   std::string oldFile = args[1];
   std::string newFile = args[2];
   std::string format;

   // Parse options
   for (size_t i = 3; i < args.size(); ++i)
   {
      if (args[i] == "--format" && i + 1 < args.size())
      {
         format = args[++i];
      }
      else if (args[i] == "--help")
      {
         printUsage("heimdall-validate");
         return 0;
      }
   }

   // Auto-detect format if not specified
   if (format.empty())
   {
      format = detectFormat(oldFile);
      if (format.empty())
      {
         std::cerr << "Error: Cannot auto-detect SBOM format. Please specify with --format\n";
         return 1;
      }
   }

   // Create comparator
   UnifiedSBOMComparator comparator;

   // Compare
   std::cout << "Comparing " << oldFile << " and " << newFile << " (" << format << " format)...\n";
   auto differences = comparator.compare(oldFile, newFile);

   // Print results
   std::cout << "\nComparison Results:\n";
   std::cout << "==================\n";

   auto stats = comparator.getDiffStatistics(differences);
   std::cout << "Total differences: " << differences.size() << "\n";
   std::cout << "Added: " << stats["added"] << "\n";
   std::cout << "Removed: " << stats["removed"] << "\n";
   std::cout << "Modified: " << stats["modified"] << "\n";
   std::cout << "Unchanged: " << stats["unchanged"] << "\n\n";

   printDetailedDifferences(differences);

   return 0;
}

/**
 * @brief Generate a diff report between two SBOM files
 * @param args Command-line arguments (expects args[1] and args[2] to be file paths)
 * @return 0 if successful, 1 if error
 */
int diffCommand(const std::vector<std::string>& args)
{
   if (args.size() < 3)
   {
      std::cerr << "Error: diff command requires two file paths\n";
      return 1;
   }

   std::string oldFile = args[1];
   std::string newFile = args[2];
   std::string format;
   std::string reportFormat = "text";

   // Parse options
   for (size_t i = 3; i < args.size(); ++i)
   {
      if (args[i] == "--format" && i + 1 < args.size())
      {
         format = args[++i];
      }
      else if (args[i] == "--report-format" && i + 1 < args.size())
      {
         reportFormat = args[++i];
      }
      else if (args[i] == "--help")
      {
         printUsage("heimdall-validate");
         return 0;
      }
   }

   // Auto-detect format if not specified
   if (format.empty())
   {
      format = detectFormat(oldFile);
      if (format.empty())
      {
         std::cerr << "Error: Cannot auto-detect SBOM format. Please specify with --format\n";
         return 1;
      }
   }

   // Create comparator
   UnifiedSBOMComparator comparator;

   // Compare
   std::cout << "Generating diff report for " << oldFile << " and " << newFile << "...\n";
   auto differences = comparator.compare(oldFile, newFile);

   // Generate report
   std::string report = comparator.generateDiffReport(differences, reportFormat);
   std::cout << report;

   return 0;
}

/**
 * @brief Merge multiple SBOM files into one
 * @param args Command-line arguments (expects file paths and --output option)
 * @return 0 if successful, 1 if error
 */
int mergeCommand(const std::vector<std::string>& args)
{
   if (args.size() < 2)
   {
      std::cerr << "Error: merge command requires at least one input file\n";
      return 1;
   }

   std::vector<std::string> inputFiles;
   std::string              outputFile;
   std::string              format  = "cyclonedx";
   std::string              version = "1.6";

   // Parse arguments
   for (size_t i = 1; i < args.size(); ++i)
   {
      if (args[i] == "--output" && i + 1 < args.size())
      {
         outputFile = args[++i];
      }
      else if (args[i] == "--format" && i + 1 < args.size())
      {
         format = args[++i];
      }
      else if (args[i] == "--version" && i + 1 < args.size())
      {
         version = args[++i];
      }
      else if (args[i] == "--help")
      {
         printUsage("heimdall-validate");
         return 0;
      }
      else if (args[i][0] != '-')
      {
         inputFiles.push_back(args[i]);
      }
   }

   if (inputFiles.empty())
   {
      std::cerr << "Error: No input files specified\n";
      return 1;
   }

   if (outputFile.empty())
   {
      std::cerr << "Error: Output file not specified (use --output)\n";
      return 1;
   }

   // Create comparator
   UnifiedSBOMComparator comparator;

   // Merge
   std::cout << "Merging " << inputFiles.size() << " SBOM files...\n";
   std::string mergedContent = comparator.merge(inputFiles, format, version);

   // Write output
   std::ofstream output(outputFile);
   if (!output.is_open())
   {
      std::cerr << "Error: Cannot write to output file: " << outputFile << "\n";
      return 1;
   }

   output << mergedContent;
   output.close();

   std::cout << "Merged SBOM written to: " << outputFile << "\n";
   return 0;
}

/**
 * @brief Main entry point for the heimdall-validate tool
 * @param argc Argument count
 * @param argv Argument vector
 * @return Exit code
 */
int main(int argc, char* argv[])
{
   if (argc < 2)
   {
      printUsage(argv[0]);
      return 1;
   }

   std::string              command = argv[1];
   std::vector<std::string> args(argv + 1, argv + argc);

   if (command == "--help" || command == "-h")
   {
      printUsage(argv[0]);
      return 0;
   }
   else if (command == "validate")
   {
      return validateCommand(args);
   }
   else if (command == "verify-signature")
   {
      return verifySignatureCommand(args);
   }
   else if (command == "compare")
   {
      return compareCommand(args);
   }
   else if (command == "diff")
   {
      return diffCommand(args);
   }
   else if (command == "merge")
   {
      return mergeCommand(args);
   }
   else
   {
      std::cerr << "Error: Unknown command: " << command << "\n";
      printUsage(argv[0]);
      return 1;
   }
}