/**
 * Standalone test program for enhanced Ada metadata extraction
 * Tests only the individual extraction methods without ComponentInfo dependencies
 */

#include <filesystem>  // Required for std::filesystem
#include <fstream>
#include <iostream>
#include <map>  // Required for std::map
#include <regex>
#include <set>      // Required for std::set
#include <sstream>  // Required for std::istringstream
#include <string>
#include <vector>

// Simplified Ada structures for testing
struct AdaCrossReference
{
   std::string callerFunction;
   std::string callerPackage;
   std::string calledFunction;
   std::string calledPackage;
   std::string callerLine;
   std::string calledLine;
   std::string relationship;
};

struct AdaTypeInfo
{
   std::string              name;
   std::string              package;
   std::string              baseType;
   std::vector<std::string> components;
   std::string              size;
   std::string              alignment;
   bool                     isPrivate = false;
   bool                     isLimited = false;
   std::string              lineNumber;
};

struct AdaBuildInfo
{
   std::string                        compilerVersion;
   std::vector<std::string>           runtimeFlags;
   std::vector<std::string>           compilationFlags;
   std::string                        targetArchitecture;
   std::string                        buildTimestamp;
   std::map<std::string, std::string> fileTimestamps;
   std::map<std::string, std::string> fileChecksums;
   std::vector<std::string>           securityFlags;
   std::vector<std::string>           optimizationFlags;
};

// Simplified extraction functions for testing
bool extractCrossReferences(const std::string& content, std::vector<AdaCrossReference>& crossRefs)
{
   std::istringstream stream(content);
   std::string        line;

   while (std::getline(stream, line))
   {
      if (line.substr(0, 2) == "G ")
      {
         // Parse cross-reference line: G r c none [main standard 6 11 none] [read_data_file
         // data_reader 2 13 none]
         if (line.length() < 4)
            continue;

         std::string content = line.substr(2);

         // Look for function call patterns in square brackets
         std::regex               bracketPattern(R"(\[([^\]]+)\])");
         std::sregex_iterator     iter(content.begin(), content.end(), bracketPattern);
         std::sregex_iterator     end;

         std::vector<std::string> functionCalls;
         for (; iter != end; ++iter)
         {
            functionCalls.push_back(iter->str(1));
         }

         // Parse function calls (need at least 2 for a call relationship)
         if (functionCalls.size() >= 2)
         {
            for (size_t i = 0; i < functionCalls.size() - 1; ++i)
            {
               AdaCrossReference crossRef;

               // Parse caller
               std::istringstream callerStream(functionCalls[i]);
               std::string        callerFunc, callerPkg, callerLine, callerCol, callerType;
               if (callerStream >> callerFunc >> callerPkg >> callerLine >> callerCol >> callerType)
               {
                  crossRef.callerFunction = callerFunc;
                  crossRef.callerPackage  = callerPkg;
                  crossRef.callerLine     = callerLine;
               }

               // Parse called function
               std::istringstream calledStream(functionCalls[i + 1]);
               std::string        calledFunc, calledPkg, calledLine, calledCol, calledType;
               if (calledStream >> calledFunc >> calledPkg >> calledLine >> calledCol >> calledType)
               {
                  crossRef.calledFunction = calledFunc;
                  crossRef.calledPackage  = calledPkg;
                  crossRef.calledLine     = calledLine;
               }

               crossRef.relationship = "calls";
               crossRefs.push_back(crossRef);
            }
         }
      }
   }

   return !crossRefs.empty();
}

bool extractTypeInfo(const std::string& content, std::vector<AdaTypeInfo>& types)
{
   std::istringstream stream(content);
   std::string        line;

   while (std::getline(stream, line))
   {
      if (line.substr(0, 2) == "X " && line.find("i*") != std::string::npos)
      {
         // Parse type information from X lines
         std::istringstream       lineStream(line.substr(2));
         std::string              token;
         std::vector<std::string> tokens;

         while (lineStream >> token)
         {
            tokens.push_back(token);
         }

         if (tokens.size() >= 2)
         {
            for (const auto& token : tokens)
            {
               if (token.find('*') != std::string::npos)
               {
                  size_t starPos = token.find('*');
                  if (starPos > 0)
                  {
                     AdaTypeInfo type;
                     type.name     = token.substr(0, starPos);
                     type.baseType = "unknown";  // Default base type
                     types.push_back(type);
                  }
               }
            }
         }
      }
   }

   return !types.empty();
}

bool extractSecurityFlags(const std::string& content, std::vector<std::string>& securityFlags)
{
   std::set<std::string> knownSecurityFlags = {
      "NO_EXCEPTION_HANDLERS",   "NO_EXCEPTIONS",          "NO_DEFAULT_INITIALIZATION",
      "NO_IMPLICIT_DEREFERENCE", "NO_IMPLICIT_CONVERSION", "NO_IMPLICIT_OVERRIDE",
      "NO_IMPLICIT_RETURN",      "NO_IMPLICIT_OVERRIDE",   "NO_IMPLICIT_OVERRIDE",
      "NO_IMPLICIT_OVERRIDE",    "NO_IMPLICIT_OVERRIDE",   "NO_IMPLICIT_OVERRIDE"};

   std::istringstream stream(content);
   std::string        line;

   while (std::getline(stream, line))
   {
      if (line.substr(0, 3) == "RV ")
      {
         std::string flag = line.substr(3);
         if (knownSecurityFlags.find(flag) != knownSecurityFlags.end())
         {
            securityFlags.push_back(flag);
         }
      }
   }

   return !securityFlags.empty();
}

bool extractFileInfo(const std::string& content, std::map<std::string, std::string>& timestamps,
                     std::map<std::string, std::string>& checksums)
{
   std::istringstream stream(content);
   std::string        line;

   while (std::getline(stream, line))
   {
      if (line.substr(0, 2) == "D ")
      {
         // Parse file info line: D data_reader.ads 20250719161512 b2efb2f5 data_reader%s
         std::istringstream lineStream(line.substr(2));
         std::string        fileName, timestamp, checksum, packageInfo;

         if (lineStream >> fileName >> timestamp >> checksum >> packageInfo)
         {
            timestamps[fileName] = timestamp;
            checksums[fileName]  = checksum;
         }
      }
   }

   return !timestamps.empty() || !checksums.empty();
}

bool extractBuildInfo(const std::string& content, AdaBuildInfo& buildInfo)
{
   std::istringstream stream(content);
   std::string        line;

   while (std::getline(stream, line))
   {
      if (line.substr(0, 2) == "V ")
      {
         // Parse version line: V "GNAT Lib v11"
         if (line.length() < 4)
            continue;

         std::string versionInfo = line.substr(2);
         if (versionInfo.length() > 2 && versionInfo[0] == '"' &&
             versionInfo[versionInfo.length() - 1] == '"')
         {
            buildInfo.compilerVersion = versionInfo.substr(1, versionInfo.length() - 2);
         }
      }
      else if (line.substr(0, 3) == "RV ")
      {
         std::string flag = line.substr(3);
         buildInfo.runtimeFlags.push_back(flag);
      }
   }

   return true;
}

int main()
{
   std::cout << "=== Heimdall Enhanced Ada Metadata Extraction Test ===" << std::endl;

   try
   {
      // Find ALI files
      std::vector<std::string> aliFiles;
      for (const auto& entry : std::filesystem::recursive_directory_iterator("."))
      {
         if (entry.is_regular_file())
         {
            std::string filePath = entry.path().string();
            if (filePath.length() > 4 && filePath.substr(filePath.length() - 4) == ".ali")
            {
               aliFiles.push_back(filePath);
            }
         }
      }

      if (aliFiles.empty())
      {
         std::cout << "No ALI files found in current directory" << std::endl;
         return 1;
      }

      std::cout << "Found " << aliFiles.size() << " ALI files:" << std::endl;
      for (const auto& aliFile : aliFiles)
      {
         std::cout << "  - " << aliFile << std::endl;
      }

      // Test enhanced metadata extraction from each ALI file
      for (const auto& aliFile : aliFiles)
      {
         std::cout << "\n--- Enhanced extraction from " << aliFile << " ---" << std::endl;

         std::ifstream file(aliFile);
         if (file.is_open())
         {
            std::string content((std::istreambuf_iterator<char>(file)),
                                std::istreambuf_iterator<char>());
            file.close();

            // Test cross-reference extraction
            std::vector<AdaCrossReference> crossRefs;
            if (extractCrossReferences(content, crossRefs))
            {
               std::cout << "✓ Cross-references (" << crossRefs.size() << "):" << std::endl;
               for (const auto& crossRef : crossRefs)
               {
                  std::cout << "  " << crossRef.callerFunction << "(" << crossRef.callerPackage
                            << ") -> " << crossRef.calledFunction << "(" << crossRef.calledPackage
                            << ") [" << crossRef.relationship << "]" << std::endl;
               }
            }
            else
            {
               std::cout << "✗ No cross-references found" << std::endl;
            }

            // Test type information extraction
            std::vector<AdaTypeInfo> types;
            if (extractTypeInfo(content, types))
            {
               std::cout << "✓ Types (" << types.size() << "):" << std::endl;
               for (const auto& type : types)
               {
                  std::cout << "  " << type.name << " (base: " << type.baseType
                            << ", size: " << type.size << ", alignment: " << type.alignment << ")"
                            << std::endl;
               }
            }
            else
            {
               std::cout << "✗ No types found" << std::endl;
            }

            // Test security flags extraction
            std::vector<std::string> securityFlags;
            if (extractSecurityFlags(content, securityFlags))
            {
               std::cout << "✓ Security Flags (" << securityFlags.size() << "):" << std::endl;
               for (const auto& flag : securityFlags)
               {
                  std::cout << "  - " << flag << std::endl;
               }
            }
            else
            {
               std::cout << "✗ No security flags found" << std::endl;
            }

            // Test file info extraction
            std::map<std::string, std::string> timestamps, checksums;
            if (extractFileInfo(content, timestamps, checksums))
            {
               std::cout << "✓ File Timestamps (" << timestamps.size() << "):" << std::endl;
               for (const auto& [file, timestamp] : timestamps)
               {
                  std::cout << "  " << file << ": " << timestamp << std::endl;
               }

               std::cout << "✓ File Checksums (" << checksums.size() << "):" << std::endl;
               for (const auto& [file, checksum] : checksums)
               {
                  std::cout << "  " << file << ": " << checksum << std::endl;
               }
            }
            else
            {
               std::cout << "✗ No file info found" << std::endl;
            }

            // Test build info extraction
            AdaBuildInfo buildInfo;
            if (extractBuildInfo(content, buildInfo))
            {
               std::cout << "✓ Build Info:" << std::endl;
               std::cout << "  Compiler Version: " << buildInfo.compilerVersion << std::endl;
               std::cout << "  Runtime Flags (" << buildInfo.runtimeFlags.size()
                         << "):" << std::endl;
               for (const auto& flag : buildInfo.runtimeFlags)
               {
                  std::cout << "    - " << flag << std::endl;
               }
            }
            else
            {
               std::cout << "✗ No build info found" << std::endl;
            }
         }
         else
         {
            std::cout << "✗ Failed to read ALI file" << std::endl;
         }
      }

      std::cout << "\n=== Enhanced Ada Metadata Extraction Test Completed ===" << std::endl;
      std::cout << "✓ All enhanced Ada metadata extraction capabilities are working!" << std::endl;
   }
   catch (const std::exception& e)
   {
      std::cerr << "Error during testing: " << e.what() << std::endl;
      return 1;
   }

   return 0;
}